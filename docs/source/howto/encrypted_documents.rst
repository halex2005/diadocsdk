Работа с зашифрованными документами
===================================
 
Счета-фактуры
-------------

Формирование документа
~~~~~~~~~~~~~~~~~~~~~~

Одна из ценностей шифрования - это закрытость содержимого документов для оператора ЭДО, поэтому мы не рассматриваем вариант формирования документа с использованием методов генерации в Диадоке.

Формирование подходящего для отправки документа состоит из следующих шагов:

-  сформировать xml-файл счета-фактуры в соответствии с утвержденным ФНС форматом `XML-схема счета-фактуры (СФ) <https://diadoc.kontur.ru/sdk/xsd/ON_SFAKT_1_897_01_05_02_01.xsd>`__, `XML-схема корректировочного счета-фактуры (КСФ) <https://diadoc.kontur.ru/sdk/xsd/ON_KORSFAKT_1_911_01_05_02_01.xsd>`__;

-  подписать  xml-файл счета-фактуры квалифицированной электронной подписью

-  зашифровать xml-файл счета-фактуры на открытые ключи, для которых должна быть доступна расшифровка; файл подписи шифровать не следует.

Для формирования, подписания и зашифрования файла можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
Отправка документа
~~~~~~~~~~~~~~~~~~

Подготовленный XML-файл СФ/ИСФ/КСФ/ИКСФ с подписью следует отправить с помощью команды :doc:`../http/PostMessage`.

Для этого нужно подготовить структуру :doc:`../proto/MessageToPost` следующим образом:

-  в значение атрибута ``FromBoxId`` указываем идентификатор ящика отправителя,

-  в значение атрибута ``ToBoxId`` указываем идентификатор ящика получателя

-  для передачи документа нужно использовать атрибут ``EncryptedInvoices``, описываемый структурой :doc:`../proto/EncryptedInvoiceAttachment`

-  внутри структуры :doc:`../proto/EncryptedInvoiceAttachment` находится вложенная структура :doc:`../proto/SignedContent`,

-  сам XML-файл нужно передать в атрибут :doc:`../proto/Content`, подпись продавца в атрибут ``Signature``
 
Описание структур, используемых при отправке СФ:

.. code-block:: protobuf

    message MessageToPost {
        required string FromBoxId = 1;
        optional string ToBoxId = 2;
        repeated EncryptedInvoiceAttachment EncryptedInvoices= 3;
    }
     
    message EncryptedInvoiceAttachment {
        required SignedContent SignedContent = 1;
        optional string Comment = 3;
    }
     
    message SignedContent {
        optional bytes Content = 1;
        optional bytes Signature = 2;
    }

После успешной отправки необходимо получить подтверждение оператора :doc:`InvoiceConfirmation <../proto/Entity message>` и отправить в ответ извещение о получении данного подтверждения - аналогично работе с :doc:`незашифрованными счетами-фактурами <example_send_invoice>`. Шифрование извещений не предусмотрено.
 

Обработка входящего документа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сначала необходимо найти входящие зашифрованные счета-фактуры, для которых требуется обработка, используем метод :doc:`../http/GetDocuments`:

-  в значение параметра ``boxId`` указываем идентификатор ящика, в котором следует выполнить поиск входящих документов

-  параметр ``filterCategory`` задается в виде строки, в данном примере "AnyInvoiceDocumentType.InboundNotFinished"

В теле ответа вернется список документов в виде структуры :doc:`../proto/DocumentList` с вложенной структурой :doc:`../proto/Document`:

-  выбираем документы, для которых флаг ``IsEncryptedContent = true`` и атрибут ``SenderSignatureStatus = SenderSignatureUnchecked``

-  для каждого из этих документов запоминаем: ``MessageId``, ``EntityId``
 
Теперь нужно скачать найденные документы и подписи к ним:

-  с помощью метода :doc:`../http/GetMessage` для каждой пары ``MessageId``, ``EntityId`` получаем сообщения в виде структуры :doc:`../proto/Message` с вложенной структурой :doc:`Entity <../proto/Entity message>`

-  забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл зашифрованного счета-фактуры)

-  забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityType`` = ``Signature`` и атрибут ``ParentEntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл подписи)

-  полученный файл счета-фактуры следует расшифровать, а затем выполнить проверку подписи.
 
Затем необходимо сообщить в Диадок результат проверки подписи с помощью метода :doc:`../http/PostMessagePatch`. Для этого нужно подготовить структуру :doc:`../proto/MessagePatchToPost` следующим образом:

-  в значение атрибута ``BoxId`` указываем идентификатор ящика, в котором лежит входящий счет-фактура

-  в значение атрибуте ``MessageId`` указываем идентификатор сообщения для соответствующего счета-фактуры (этот ``MessageId`` был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  для передачи результата проверки подписи используется атрибут ``SignatureVerifications``, описываемый структурой :doc:`SignatureVerification <../proto/MessagePatchToPost>`

-  в значение атрибута ``InitialDocumentId`` указываем идентификатор документа для соответствующего счета-фактуры (этот ``EntityId`` был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  устанавливаем флаг ``IsValid`` в соответствии с результатом проверки подписи
 
Описание структур, используемых при отправке результата проверки подписи:

.. code-block:: protobuf

    message MessagePatchToPost {
        required string BoxId = 1;
        required string MessageId = 2;
        repeated SignatureVerification SignatureVerifications = 18;
    }
     
    message SignatureVerification {
        required string InitialDocumentId = 1;
        required bool IsValid = 2;
        optional string ErrorMessage = 3;
    }
 
Для расшифровки документа и проверки подписи можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
После успешной проверки подписи необходимо сформировать и отправить технологические квитанции (извещения) - аналогично работе с :doc:`незашифрованными счетами-фактурами <example_send_invoice>`. Шифрование извещений не предусмотрено.
 
Товарные накладные (Торг-12)
----------------------------

Формирование документа
~~~~~~~~~~~~~~~~~~~~~~

Одна из ценностей шифрования - это закрытость содержимого документов для оператора ЭДО, поэтому мы не рассматриваем вариант формирования документа с использованием методов генерации в Диадоке.

Формирование подходящего для отправки документа состоит из следующих шагов:

-  сформировать xml-файл титула продавца товарной накладной в соответствии с утвержденным ФНС форматом

-  подписать  xml-файл титула продавца квалифицированной электронной подписью

-  зашифровать xml-файл титула продавца на открытые ключи, для которых должна быть доступна расшифровка; файл подписи шифровать не следует.

Для формирования, подписания и зашифрования файла можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
Отправка документа
~~~~~~~~~~~~~~~~~~

Подготовленный XML-файл титула продавца с подписью следует отправить с помощью команды :doc:`../http/PostMessage`.

Для этого нужно подготовить структуру :doc:`../proto/MessageToPost` следующим образом:

-  в значение атрибута ``FromBoxId`` указываем идентификатор ящика отправителя,

-  в значение атрибута ``ToBoxId`` указываем идентификатор ящика получателя

-  для передачи документа нужно использовать атрибут ``EncryptedXmlTorg12SellerTitles``, описываемый структурой :doc:`../proto/EncryptedXmlDocumentAttachment`

-  внутри структуры :doc:`../proto/EncryptedXmlDocumentAttachment` находится вложенная структура :doc:`../proto/SignedContent`,

-  сам XML-файл нужно передать в атрибут ``Content``, подпись продавца в атрибут ``Signature``
 
Описание структур, используемых при отправке торг-12:

.. code-block:: protobuf

    message MessageToPost {
        required string FromBoxId = 1;
        optional string ToBoxId = 2;
        repeated EncryptedXmlDocumentAttachment EncryptedXmlTorg12SellerTitles = 29;
    }
     
    message EncryptedXmlDocumentAttachment {
        required SignedContent SignedContent = 1;
        optional string Comment = 3;
    }
     
    message SignedContent {
        optional bytes Content = 1;
        optional bytes Signature = 2;
    }
 
Обработка входящего документа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сначала необходимо найти входящие зашифрованные товарные накладные, для которых требуется обработка, используем метод :doc:`../http/GetDocuments`:

-  в значение параметра ``boxId`` указываем идентификатор ящика, в котором следует выполнить поиск входящих документов

-  параметр ``filterCategory`` задается в виде строки, в данном примере "AnyBilateralDocumentType.InboundWaitingForRecipientSignature"

В теле ответа вернется список документов в виде структуры :doc:`../proto/DocumentList` с вложенной структурой :doc:`../proto/Document`

-  выбираем документы, для которых флаг ``IsEncryptedContent = true`` и атрибут ``SenderSignatureStatus = SenderSignatureUnchecked``

-  для каждого из этих документов запоминаем: ``MessageId``, ``EntityId``
 
Теперь нужно скачать найденные документы и подписи к ним:

-  с помощью метода :doc:`../http/GetMessage` для каждой пары ``MessageId``, ``EntityId`` получаем сообщения в виде структуры :doc:`../proto/Message` с вложенной структурой :doc:`Entity <../proto/Entity message>`

-  забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл зашифрованного титула продавца)

-  забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityType = Signature`` и атрибут ``ParentEntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл подписи)

-  полученный файл титула продавца следует расшифровать, а затем выполнить проверку подписи.
 
Затем необходимо сообщить в Диадок результат проверки подписи с помощью метода :doc:`../http/PostMessagePatch`. Для этого нужно подготовить структуру :doc:`../proto/MessagePatchToPost` следующим образом:

-  в значение атрибута ``BoxId`` указываем идентификатор ящика, в котором лежит входящий документ

-  в значение атрибуте ``MessageId`` указываем идентификатор сообщения для соответствующей товарной накладной (этот ``MessageId`` был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  для передачи результата проверки подписи используется атрибут ``SignatureVerifications``, описываемый структурой :doc:`SignatureVerification <../proto/MessagePatchToPost>`

-  в значение атрибута ``InitialDocumentId`` указываем идентификатор документа для соответствующей товарной накладной (этот ``EntityId`` был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  устанавливаем флаг ``IsValid`` в соответствии с результатом проверки подписи
 
Описание структур, используемых при отправке результата проверки подписи:

.. code-block:: protobuf

    message MessagePatchToPost {
        required string BoxId = 1;
        required string MessageId = 2;
        repeated SignatureVerification SignatureVerifications = 18;
    }
     
    message SignatureVerification {
        required string InitialDocumentId = 1;
        required bool IsValid = 2;
        optional string ErrorMessage = 3;
    }
 
Для расшифровки документа и проверки подписи можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
После успешной проверки подписи необходимо сформировать и отправить титул покупателя - аналогично работе с незашифрованными товарными накладными. Шифрование титула покупателя не предусмотрено.
 
Акты выполненных работ
----------------------

Формирование документа
~~~~~~~~~~~~~~~~~~~~~~

Одна из ценностей шифрования - это закрытость содержимого документов для оператора ЭДО, поэтому мы не рассматриваем вариант формирования документа с использованием методов генерации в Диадоке.

Формирование подходящего для отправки документа состоит из следующих шагов:

-  сформировать xml-файл титула исполнителя акта выполненных работ в соответствии с утвержденным ФНС форматом

-  подписать  xml-файл титула исполнителя квалифицированной электронной подписью

-  зашифровать xml-файл титула исполнителя на открытые ключи, для которых должна быть доступна расшифровка; файл подписи шифровать не следует.

Для формирования, подписания и зашифрования файла можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
Отправка документа
~~~~~~~~~~~~~~~~~~

Подготовленный XML-файл титула исполнителя с подписью следует отправить с помощью команды :doc:`../http/PostMessage`.

Для этого нужно подготовить структуру :doc:`../proto/MessageToPost` следующим образом:

-  в значение атрибута ``FromBoxId`` указываем идентификатор ящика отправителя,

-  в значение атрибута ``ToBoxId`` указываем идентификатор ящика получателя

-  для передачи документа нужно использовать атрибут ``EncryptedXmlAcceptanceCertificateSellerTitles``, описываемый структурой :doc:`../proto/EncryptedXmlDocumentAttachment`

-  внутри структуры :doc:`../proto/EncryptedXmlDocumentAttachment` находится вложенная структура :doc:`../proto/SignedContent`,

-  сам XML-файл нужно передать в атрибут ``Content``, подпись продавца в атрибут ``Signature``
 
Описание структур, используемых при отправке актов:

.. code-block:: protobuf

    message MessageToPost {
        required string FromBoxId = 1;
        optional string ToBoxId = 2;
        repeated EncryptedXmlDocumentAttachment EncryptedXmlAcceptanceCertificateSellerTitles = 30;
    }
     
    message EncryptedXmlDocumentAttachment {
        required SignedContent SignedContent = 1;
        optional string Comment = 3;
    }
     
    message SignedContent {
        optional bytes Content = 1;
        optional bytes Signature = 2;
    }
     
 
Обработка входящего документа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сначала необходимо найти входящие зашифрованные акты выполненных работ, для которых требуется обработка, используем метод :doc:`../http/GetDocuments`:

-  в значение параметра ``boxId`` указываем идентификатор ящика, в котором следует выполнить поиск входящих документов

-  параметр ``filterCategory`` задается в виде строки, в данном примере "AnyBilateralDocumentType.InboundWaitingForRecipientSignature"

В теле ответа вернется список документов в виде структуры :doc:`../proto/DocumentList` с вложенной структурой :doc:`../proto/Document`

-  выбираем документы, для которых флаг ``IsEncryptedContent = true`` и атрибут ``SenderSignatureStatus = SenderSignatureUnchecked``

-  Для каждого из этих документов запоминаем: ``MessageId``, ``EntityId``
 
Теперь нужно скачать найденные документы и подписи к ним:

-  С помощью метода :doc:`../http/GetMessage` для каждой пары ``MessageId``, ``EntityId`` получаем сообщения в виде структуры :doc:`../proto/Message` с вложенной структурой :doc:`Entity <../proto/Entity message>`

-  Забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл зашифрованного титула исполнителя)

-  Забираем Content из :doc:`Entity <../proto/Entity message>`, где атрибут ``EntityType = Signature`` и атрибут ``ParentEntityId`` равен ``EntityId``, указанному при вызове метода (т.е. скачиваем файл подписи)

-  Полученный файл титула исполнителя следует расшифровать, а затем выполнить проверку подписи.
 
Затем необходимо сообщить в Диадок результат проверки подписи с помощью метода :doc:`../http/PostMessagePatch`. Для этого нужно подготовить структуру :doc:`../proto/MessagePatchToPost` следующим образом:

-  в значение атрибута ``BoxId`` указываем идентификатор ящика, в котором лежит входящий документ

-  в значение атрибуте ``MessageId`` указываем идентификатор сообщения для соответствующего акта выполненных работ (этот ``MessageId`` был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  для передачи результата проверки подписи используется атрибут ``SignatureVerifications``, описываемый структурой :doc:`SignatureVerification <../proto/MessagePatchToPost>`

-  в значение атрибута ``InitialDocumentId`` указываем идентификатор документа для соответствующего акта выполненных работ (этот EntityId был получен в ответе на вызов :doc:`../http/GetDocuments`)

-  устанавливаем флаг ``IsValid`` в соответствии с результатом проверки подписи
 
Описание структур, используемых при отправке результата проверки подписи:

.. code-block:: protobuf

    message MessagePatchToPost {
        required string BoxId = 1;
        required string MessageId = 2;
        repeated SignatureVerification SignatureVerifications = 18;
    }
     
    message SignatureVerification {
        required string InitialDocumentId = 1;
        required bool IsValid = 2;
        optional string ErrorMessage = 3;
    }
 
Для расшифровки документа и проверки подписи можно использовать специальную сборку com-компоненты DiadocComAPI, которую мы готовы предоставить по запросу.
 
После успешной проверки подписи необходимо сформировать и отправить титул заказчика - аналогично работе с незашифрованными актами выполненных работ. Шифрование титула заказчика не предусмотрено.
